#include <iostream>
#include <stack>
using namespace std;
#define N 8  //8个格子
bool isocupy[N] = { 0 };//表示该行时候被占用了
struct queen{//记录每个皇后的坐标
	int x;
	int y;
};
stack <queen> s, temp;
char pic[N][N] = { '.' };//用来输出图像
int n = 0;//表示可能数目
bool judge(int x, int y);//判断是否处于同一行、同一列、同一斜线上
void sovled();
void print();//打印可能结果
int main(){
	memset(pic, '.', sizeof(pic));
	sovled();
}
void sovled(){
	if (s.empty()){	//如果栈空
		queen temp_q;
		temp_q.x = 0;
		for (temp_q.y = 0; temp_q.y < N; temp_q.y++){
			s.push(temp_q);
			isocupy[temp_q.y] = true;
			sovled();
			s.pop();
			isocupy[temp_q.y] = false;
		}
	}
	else{
		if (s.size() == N){//如果栈满
			temp = s;
			n++;
			print();
			return;
		}
		else{
			queen temp_q;
			temp_q.x = s.top().x + 1;
			for (temp_q.y = 0; temp_q.y < N; temp_q.y++){
				if (judge(temp_q.x, temp_q.y)){//如果符合条件
					s.push(temp_q);
					isocupy[temp_q.y] = true;
					sovled();
					s.pop();
					isocupy[temp_q.y] = false;
				}
			}
		}
	}
}
bool judge(int x, int y){
	stack <queen> temp_ = s;
	while (!temp_.empty()){
		queen temp_q = temp_.top();
		if (isocupy[y] || (abs(temp_q.x - x) == abs(temp_q.y - y)))
			return false;
		temp_.pop();
	}
	return true;
}
void print(){
	for (int i = 0; i < N; i++){
		pic[temp.top().x][temp.top().y] = 'X';
		temp.pop();
	}
	for (int i = 0; i < N; i++){
		cout << endl;
		for (int j = 0; j < N; j++)
			cout << pic[i][j] << " ";
	}
	cout << endl << "----------------" << endl;
	memset(pic, '.', sizeof(pic));
	cout << "n= " << n << endl;
}